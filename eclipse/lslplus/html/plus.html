<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
	<title>What Do You Mean &quot;Plus&quot;?</title>
	<link rel="stylesheet" type="text/css" href="book.css"/>
</head>

<body>
<h1>What Do You Mean &quot;Plus&quot;?</h1>
<div class="content">
<p>
The 'compiler' for LSL Plus accepts the basic LSL scripting language code, <em>plus</em> some
additional extensions.  That may sound a bit strange, since unless the LSL compiler within SL does
not accept those extensions, what use could they be?  What the LSL Plus compiler does is take as
input LSL Plus code, and it produces 'straight' LSL code as a compiled output.  If you feed it
plain LSL code, it will simply produce equivalent LSL code as its output (in addition to validating
that it is syntactically correct, and allowing you to test it).  But LSL Plus also allows you to 
separate you code into <em>scripts</em> and <em>modules</em>.  If you have some useful functions that
you use over and over again in different LSL scripts, you have to continually cut and paste them into
each script that you write (and then, assuming you are editing offline, paste the whole thing into 
the SL LSL editor).  With LSL Plus, you can separate these reusable functions (and global variables)
into modules, and <em>import</em> these modules into your scripts (and into other modules).  When
the scripts are compiled, the resulting plain LSL script can then be uploaded (cut-n-pasted) into
SL.
</p>

<p>At this point some clever and/or skeptical reader might be mumbling something like
 &quot;Couldn't you just use the C preprocessor instead, and use the #include directive?&quot;  The answer
is, yeah, probably, but a &quot;language aware&quot; import mechanism is potentially more powerful
than source pre-processing.  Also, I didn't think of that until after I'd gotten it working.
The import mechanism, though, is pretty useful; it allows the symbols you import to be qualified with
a prefix, so that you can avoid namespace problems, for example.  It allows parameterization of the 
import, right now just allowing the binding of <em>free variables</em> that the module declares to
variables within the scope of the script.  I envision extending this to providing functions and types
as import parameters as well, which will allow creation of generic modules, such as a generic sort 
module.  But if you just want to use LSL Plus to edit and test &quot;straight&quot; LSL code, the 
<em>plus</em> features won't get in your way.</p>

<p>
Here is a basic example of module usage:</p>

<p>Module: avogadro.lslm</p>
<pre>
$module ()

float avogadro = 6.022142E+23;

float to_moles(float molecules) {
    return molecules / avogadro;
}
</pre>

<p>Script: really_useful.lslp</p>

<pre>
$import avogadro.lslm () my_;

default {
    state_entry() {
        llSay(0, "Avogadro's number is: " + (string)my_avogadro);
        llSay(0, "5 billion molecules is: " + ((string)my_to_moles(5000000000.0)) + " moles");
    }
}
</pre>

<p>
In the above example, the inclusion of the prefix &quot;my_&quot; is not necessary.  You could
omit it on the first line, in the import statement, and remove it from references to the avogadro
constant and the to_moles function.  But if you happen to have other avogadro's number definitions
and mole conversion functions scattered around in your script already (and, let's face it, who
doesn't?) then this feature will prevent name clashes.</p>
</div>

</body>
</html>